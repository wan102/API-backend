import { TrueCondition as TrueConditionFunction } from "./TrueCondition";
import { EqualsCondition as EqualsConditionFucntion } from "./EqualsCondition";
import { NotEqualsCondition as NotEqualsConditionFunction } from "./NotEqualsCondition";
import { NotCondition as NotConditionFunction } from "./NotCondition";
import { ListContainsCondition as ListContainsConditionFunction } from "./ListContainsCondition";
import { OrCondition as OrConditionFunction } from "./OrCondition";
import { AndCondition as AndConditionFunction } from "./AndCondition";
import { StartsWithCondition } from "./StartsWithCondition";
import { ICondition, IDictionary, IFunctionCondition } from "../core";
export declare class ConditionUtil {
    static readonly AND: AndConditionFunction;
    static readonly TRUE: TrueConditionFunction;
    static readonly EQUALS: EqualsConditionFucntion;
    static readonly LIST_CONTAINS: ListContainsConditionFunction;
    static readonly NOT_EQUALS: NotEqualsConditionFunction;
    static readonly NOT: NotConditionFunction;
    static readonly OR: OrConditionFunction;
    static readonly STARTS_WITH: StartsWithCondition;
    private static _customConditionFunctions;
    static registerCustomConditionFunction(functionName: string, fn: IFunctionCondition): void;
    static resetCustomConditionFunctions(): void;
    static getCustomConditionFunctions(): IDictionary<IFunctionCondition>;
    static setCustomConditionFunctions(customConditionFunctions?: IDictionary<IFunctionCondition>): void;
    static validateCondition(condition: any): void;
    static evaluate(condition: ICondition, context: any): boolean | Promise<boolean>;
    static getValueByPath(context: any, valuePathOrValue: any): any;
}
